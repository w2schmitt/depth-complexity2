/* 
 * File:   bps_model.cpp
 * Author: Affonso
 *
 * Created on 16 de Maio de 2012, 14:39
 */
#include "bps_model.h"
/*
 * 
 */
int main(int argc, char** argv) {
  cmd_usage("Program to divide a model based in the lines generated by depthcomplexity3d_offline");
  
  const char *filename = cmd_option("-f", "", "Model in the OBJ or OFF format");
  const char *modelRays = cmd_option("-r", "", "OFF File with maximum intersections lines");
  
  const char *modelA = cmd_option("-fa", "", "OFF file with the first part of the model");
  const char *modelB = cmd_option("-fb", "", "OFF file with the other part of the model");
  
  try{
    if(strcmp(filename, "")==0)
      throw "No model file specified";
    
    //carrega modelo a ser dividido
    tic();
    std::ifstream file(filename);
    std::string ext = getExtension(filename);
    TriMesh mesh;
    if (ext == "off" || ext == "OFF")
      mesh = loadOFFMesh(file);
    else if (ext == "obj" || ext == "OBJ")
      mesh = loadOBJMesh(file);
    else
      throw "Unknown file type for model!";
    file.close();
    toc("Loading Mesh");
    
    //Carrega linhas com o maximo de interseções
    tic();
    std::ifstream line_file(modelRays);
    std::string ext_line = getExtension(modelRays);
    std::vector<Segment> lines;
    if (ext_line == "off" || ext_line == "OFF")
      lines = loadOFFLines(line_file);
    else
      throw "Unknown file type for lines!";
    file.close();
    toc("Loading Lines");
    
    TriMesh part_a, part_b;
    
    /*vec3d planeNormal = lines.at(0).a - lines.at(0).b,
          model_center = ((mesh.aabb.max + mesh.aabb.min)/2.0);
    planeNormal.normalize();
    cout << model_center << std::endl;*/
    vec4d plane = defineCuttingPlane(lines, mesh.aabb);//makePlane(planeNormal, model_center);
    subDivideModel(plane, mesh, part_a, part_b);
    
    //write part_a of the model
    if (strcmp(modelA, "")!=0) {
      std::string extOff = getExtension(modelA);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelA);
        writeOFFModel(part_a,fileRays);
        fileRays.close();
      } else throw "Model A file should be *.off!";
    }
    
    //write part_a of the model
    if (strcmp(modelB, "")!=0) {
      std::string extOff = getExtension(modelB);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelB);
        writeOFFModel(part_b,fileRays);
        fileRays.close();
      } else throw "Model B file should be *.off!";
    }
    
  } catch (const char* msg)  {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  } catch (std::string msg) {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  }
  
  return 0;
}


std::vector<Segment> loadOFFLines(std::istream& in){
  
  std::clog << "Loading OFF file" << std::endl;

  std::string head;
  in >> head;
  if (head != "OFF")
    throw "Does not start with OFF!";

  int nverts, nfaces, nedges;
  
  if (!(in >> nverts >> nfaces >> nedges))
    throw "Could not read number of vertices, faces, edges";

  std::vector<Segment> lines;
  lines.reserve(nfaces);
  
  std::vector<vec3d> vertices(nverts);
  for (int i=0; i<nverts; ++i) {
    in >> vertices[i].x >> vertices[i].y >> vertices[i].z;
  }
  
  for (int i=0; i<nfaces; ++i) {
    int sz, a, b;
    Segment s;
    in >> sz >> a >> b;
    s.a = vertices.at(a);
    s.b = vertices.at(b);
    lines.push_back(s);
  }
  
  std::clog << "Loaded " << lines.size() << " lines" << std::endl;
  
  return lines;
}

std::string getExtension(const std::string& filename) {
  std::string::size_type dotpos = filename.rfind(".");
  if (dotpos != std::string::npos)
    return filename.substr(dotpos+1);
  return "";
}


void writeOFFModel(const TriMesh& model, std::ostream& out){
  out << "OFF" << std::endl;
  int m_size= model.faces.size();
  
  out << m_size*3 << " " << m_size << " " << m_size*3 << std::endl;
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  for(;ite != end; ++ite){
    out << ite->a.x << " " << ite->a.y << " " << ite->a.z << std::endl;
    out << ite->b.x << " " << ite->b.y << " " << ite->b.z << std::endl;
    out << ite->c.x << " " << ite->c.y << " " << ite->c.z << std::endl;
  }
  
  for(int i= 0; i < m_size; i++){
    out << "3 " << 3*i << " " << 3*i+1 << " " << 3*i+2 << std::endl;
  }
}

void mergeTriangleBB ( BoundingBox& aabb, const Triangle t){
  aabb.merge(t.a);
  aabb.merge(t.b);
  aabb.merge(t.c);
}

void  subDivideModel(const vec4d plane, const TriMesh& model, TriMesh& partA,
        TriMesh& partB){
  vec3d model_center = ((model.aabb.max + model.aabb.min)/2.0);
  
  cout << plane << std::endl << model_center << std::endl;
  cout << dot(plane, vec4d(model_center,1))<<endl;
  
  std::size_t numModelTrian = model.faces.size();
  
  partA.faces.reserve(numModelTrian/2);
  partB.faces.reserve(numModelTrian/2);
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  
  for(;ite != end; ite++){

    bool divideTriangle;
    TriMesh *partOne,
            *partTwo;
    Triangle t;
    
    switch(getPlaneTriangleIntersection(plane, *ite)){
      case ALL_ABOVE_PLANE:
        //cout << "ALL_ABOVE_PLANE" << std::endl;
        divideTriangle = false;
        partOne = &partA;
        t = *ite;
        break;
      case ALL_BELLOW_PLANE:
        //cout << "ALL_BELLOW_PLANE" << std::endl;
        divideTriangle = false;
        partOne = &partB;
        t = *ite;
        break;
      case ONLY_A_ABOVE_PLANE:
        //cout << "ONLY_A_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_A_BELLOW_PLANE:
        //cout << "ONLY_A_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_B_ABOVE_PLANE:
        //cout << "ONLY_B_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_B_BELLOW_PLANE:
        //cout << "ONLY_B_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_C_ABOVE_PLANE:
        //cout << "ONLY_C_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      case ONLY_C_BELLOW_PLANE:
        //cout << "ONLY_C_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      default:
        cout << "ERROR: Não foi possivel determinar a possição do triangulo em relação ao plano" << std::endl;
        exit(-1);
    }
    
    //divideTriangle = false;
    
    if(!divideTriangle){
      partOne->faces.push_back(t);
      mergeTriangleBB(partOne->aabb, t);
    }else{
      Triangle halfT, tb, tc;
      
      halfT = cutTriangle(plane, t);
      
      partOne->faces.push_back(halfT);
      mergeTriangleBB(partOne->aabb, halfT);
      
      tb = Triangle();
      tb.a = halfT.b;
      tb.b = t.b;
      tb.c = t.c;
      tb.na = t.nb =
      t.nc = halfT.nb;
      partTwo->faces.push_back(tb);
      mergeTriangleBB(partTwo->aabb, tb);
      
      tc = Triangle();
      tc.a = halfT.b;
      tc.b = t.c;
      tc.c = halfT.c;
      tc.na = tc.nb =
      tc.nc = halfT.nb;
      partTwo->faces.push_back(tc);
      mergeTriangleBB(partTwo->aabb, tc);
    }
  }
}

vec4d makePlane(const vec3d& normal, const vec3d& point){
  
  double d = dot(normal, point);
  return vec4d(normal, -d);
  
}

int getPlaneTriangleIntersection(const vec4d& plane, const Triangle& triangle){
  bool AAbove,
       BAbove,
       CAbove;
  
  if(dot(plane, vec4d(triangle.a, -1)) >= 0){
    AAbove = true;
  }else{
    AAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.b, -1)) >= 0){
    BAbove = true;
  }else{
    BAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.c, -1)) >= 0){
    CAbove = true;
  }else{
    CAbove = false;
  }
  
  if(AAbove && BAbove && CAbove){ // todos acima?
    return ALL_ABOVE_PLANE;
  }else if(!AAbove && !BAbove && !CAbove){ // todos abaixo?
    return ALL_BELLOW_PLANE;
  }else if(AAbove){ //no inicio desta linha se tem certeza que a b c não estão no mesmo lado do plano
    if(BAbove){ 
      return ONLY_C_BELLOW_PLANE;
    }else{
      if(CAbove){
        return ONLY_B_BELLOW_PLANE;
      }else{
        return ONLY_A_ABOVE_PLANE;
      }
    }
  }else if(BAbove){ //AAbove = false
    if(CAbove){
      return ONLY_A_BELLOW_PLANE;
    }else{// AAbove = CAbove = false
      return ONLY_B_ABOVE_PLANE;
    }
  }else{ //AAbove = BAbove = false, como os tres não são iguais CAbove = true
    return ONLY_C_ABOVE_PLANE;
  }
}

vec3d linePlaneIntersection(const Segment& line, const vec4d& plane){
  // intersecção de uma reta e um planos com equaçoes parametricas
  // formula vista em paulbourke.net/geometry/planeline
  vec3d dir = line.a - line.b; dir.normalize();
	vec3d p0 = plane.xyz() * plane.w; //a point over the plane
	double d = dot(plane.xyz(),(p0-line.a)) / dot(plane.xyz(),dir);
	vec3d intercept = line.a + dir*d;
  
	return intercept;
  
}

/*
 * Recebe um plano e um triangulo, onde o ponto a do triangulo esta do outro lado
 * do plano em comparação com os ponto b e c. Esta rotação dos pontos do triangulo deve
 * ser feita antes da chamada da função
 */
Triangle cutTriangle(const vec4d& plane, const Triangle& triangle){
  
  vec3d new_b, new_c;
  
  new_b = linePlaneIntersection( Segment(triangle.a, triangle.b), plane);
  new_c = linePlaneIntersection( Segment(triangle.a, triangle.c), plane);
  
  Triangle triangleHalf;
  
  triangleHalf.a = triangle.a;
  triangleHalf.b = new_b;
  triangleHalf.c = new_c;
  
  triangleHalf.na = triangleHalf.nb 
          = triangleHalf.nc = triangle.na;
  return triangleHalf;
}

/*
 * Função que ira definir o plano divisor do modelo a partir das linha que atravesam
 * o modelo um numero maximo de vezes, a heuristica usada tenta diminuir ao maximo o
 * número de intersecções nos submodelos.
 */
vec4d defineCuttingPlane(const vector<Segment> lines, const BoundingBox aabb){
  
  vector<W_Plane> cutting_planes; //planes found that will be interpolated in the end 

  vector<int> retest_seg;// positions of elements with needs to be retested
  vector<int> idx_segs;// positions of elements to be tested
  idx_segs.reserve(lines.size());//in the fist pass all elements will be tested
  
  for (uint i = 0; i < lines.size(); i++){
    idx_segs.push_back(i);
  }
  
  //init test
  while(idx_segs.size() > 1){//in case there is only one line to be tested another heuristic must be used
    
    //find a inital plane to be compared with the rest of lines
    int first_idx = 1;
    bool plane_found = false;
    W_Plane cut_plane;
    
    //compare two lines to find a plane inside the aabb
    while(not plane_found){
      Segment seg_btw = 
              findSegmentBetweenLines(lines.at(idx_segs.at(0)), 
                                      lines.at(idx_segs.at(first_idx)));
      if(seg_btw.active){
           
        if(insideAABB(seg_btw.a, aabb) && insideAABB(seg_btw.b, aabb)){

          plane_found = true;
          cut_plane.p0 = (seg_btw.a + seg_btw.b)/2.0;

          vec3d normA = lines.at(idx_segs.at(0)).b - lines.at(idx_segs.at(0)).a,
                normB = lines.at(idx_segs.at(first_idx)).b - lines.at(idx_segs.at(first_idx)).a;

          normA = normA/normA.length();
          normB = normB/normB.length();

          // for the angle betwen the lines a verifications is
          // needed so the smaller angle betwen then is used
          if (dot(normA, normB) >= 0){
            cut_plane.vet_dir = normA + normB;
          }else{
            cut_plane.vet_dir = normA - normB;
          }

        }else{
          retest_seg.push_back(idx_segs.at(first_idx));
          first_idx++;
        }
      }else{
        first_idx++;
      }
    }
    
    double lines_used = 2;// 
    //start comparing plane with lines to insterpolate a new plane
    for(uint i = first_idx; i < idx_segs.size(); i++){
      Segment line_plane = Segment(cut_plane.p0, cut_plane.vet_dir+cut_plane.p0);
      Segment seg_btw = 
              findSegmentBetweenLines(line_plane, 
                                      lines.at(idx_segs.at(first_idx)));
      if(seg_btw.active){
           
        if(insideAABB(seg_btw.a, aabb) && insideAABB(seg_btw.b, aabb)){
          
          //weighted mean for the interpolations with the plan and the line
          cut_plane.p0 = (lines_used*cut_plane.p0 + seg_btw.b)/(++lines_used);

          vec3d norm = lines.at(idx_segs.at(first_idx)).b - lines.at(idx_segs.at(first_idx)).a;

          norm = norm/norm.length();

          // for the angle betwen the lines a verifications is
          // needed so the smaller angle betwen then is used
          if (dot(cut_plane.vet_dir, norm) >= 0){
            cut_plane.vet_dir += norm;
          }else{
            cut_plane.vet_dir -= norm;
          }

        }else{
          retest_seg.push_back(idx_segs.at(first_idx));
          first_idx++;
        }
      }else{//parallel lines are disconsidered
        first_idx++;
      }
    }
    
    cut_plane.weight = lines_used;
    cutting_planes.push_back(cut_plane);
    
    //setup the lined who need to be retested
    idx_segs.swap(retest_seg);
    retest_seg.clear();
  }
  
  //use another heuristic to find the cutting plane using one line
  if(not idx_segs.empty()){
    //don't do shit
  }
  
  //interpolate all the planes found
  vec3d ret_p0;
  vec3d ret_normal;
  double weights = 0;
  
  vector<W_Plane>::const_iterator ite = cutting_planes.begin();
  vector<W_Plane>::const_iterator end = cutting_planes.end();
  
  ret_p0 = ite->p0 * ite->weight;
  weights = ite->weight;
  ret_normal = ite->vet_dir;
  
  for(;ite != end; ++ite){
    ret_p0 += ite->p0*ite->weight;
    weights += ite->weight;
    
    if(dot(ret_normal, ite->vet_dir) >= 0){
      ret_normal += ite->vet_dir;
    }else{
      ret_normal -= ite->vet_dir;
    }
  }
  
  ret_normal.normalize();
  
  return makePlane(ret_normal, ret_p0);
}

/*
 * Função que acha o menor segmento de reta entre duas linhas não paralelas
 * a reta será perpendicular as duas linhas passadas,
 * caso as linhas sejam paralelas o campo active do segmento retorna do será falso.
 * O ponto inicial do segmento fara parte da primeira linha passada.
 * 
 */
Segment findSegmentBetweenLines(Segment lineA, Segment lineB){
  vec3d u = lineA.b - lineA.a,
        v = lineB.b - lineB.a,
        w0= lineA.a - lineB.a;
  
  double a = dot(u,u),
         b = dot(v,v),
         c = dot(u,v);
  
  double denominator = a*b - c*c;
  
  if (denominator == 0){ // the 2 lines are paralels
    Segment paralel = Segment();
    paralel.active = false;            
    
    return paralel;
  }
  
  double d = dot(u,w0),
         e = dot(v,w0);
  
  double Ap = (c*e-d*b)/denominator,
         Bp = (a*e-d*c)/denominator;
  
  vec3d pnt0 = lineA.a + u*Ap,
        pnt1 = lineB.a + v*Bp;
  
  return Segment(pnt0, pnt1);
  
}

/*
 * Test if point is inside the bounding box aabb 
 * 
 */ 
bool insideAABB(const vec3d point, const BoundingBox aabb){
  if(point.x > aabb.max.x) return false;  
  if(point.x < aabb.min.x) return false;
  if(point.y > aabb.max.y) return false;
  if(point.y < aabb.min.y) return false;
  if(point.z > aabb.max.z) return false;
  if(point.z < aabb.min.z) return false;
  return true;
}