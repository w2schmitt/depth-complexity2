/* 
 * File:   bps_model.cpp
 * Author: Affonso
 *
 * Created on 16 de Maio de 2012, 14:39
 */
#include <stdexcept>

#include "bps_model.h"

/*
#ifdef BPS_OFFLINE

int main(int argc, char** argv) {
  cmd_usage("Program to divide a model based in the lines generated by depthcomplexity3d_offline");
  
  const char *filename = cmd_option("-f", "", "Model in the OBJ or OFF format");
  const char *modelRays = cmd_option("-r", "", "OFF File with maximum intersections lines");
  
  const char *modelA = cmd_option("-fa", "", "OFF file with the first part of the model");
  const char *modelB = cmd_option("-fb", "", "OFF file with the other part of the model");
  
  try{
    if(strcmp(filename, "")==0)
      throw "No model file specified";
    
    //carrega modelo a ser dividido
    tic();
    std::ifstream file(filename);
    std::string ext = getExtension(filename);
    TriMesh mesh;
    if (ext == "off" || ext == "OFF")
      mesh = loadOFFMesh(file);
    else if (ext == "obj" || ext == "OBJ")
      mesh = loadOBJMesh(file);
    else
      throw "Unknown file type for model!";
    file.close();
    toc("Loading Mesh");
    
    //Carrega linhas com o maximo de interseções
    tic();
    std::ifstream line_file(modelRays);
    std::string ext_line = getExtension(modelRays);
    std::vector<Segment> lines;
    if (ext_line == "off" || ext_line == "OFF")
      lines = loadOFFLines(line_file);
    else
      throw "Unknown file type for lines!";
    file.close();
    toc("Loading Lines");
    
    TriMesh part_a, part_b;
    
    //vec3d planeNormal = lines.at(0).a - lines.at(0).b,
          model_center = ((mesh.aabb.max + mesh.aabb.min)/2.0);
    planeNormal.normalize();
    cout << model_center << std::endl;
    vec4d plane = defineCuttingPlane(lines, mesh.aabb);//makePlane(planeNormal, model_center);
    subDivideModel(plane, mesh, part_a, part_b);
    
    //write part_a of the model
    if (strcmp(modelA, "")!=0) {
      std::string extOff = getExtension(modelA);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelA);
        writeOFFModel(part_a,fileRays);
        fileRays.close();
      } else throw "Model A file should be *.off!";
    }
    
    //write part_a of the model
    if (strcmp(modelB, "")!=0) {
      std::string extOff = getExtension(modelB);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelB);
        writeOFFModel(part_b,fileRays);
        fileRays.close();
      } else throw "Model B file should be *.off!";
    }
    
  } catch (const char* msg)  {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  } catch (std::string msg) {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  }
  
  return 0;
}


std::vector<Segment> loadOFFLines(std::istream& in){
  
  std::clog << "Loading OFF file" << std::endl;

  std::string head;
  in >> head;
  if (head != "OFF")
    throw "Does not start with OFF!";

  int nverts, nfaces, nedges;
  
  if (!(in >> nverts >> nfaces >> nedges))
    throw "Could not read number of vertices, faces, edges";

  std::vector<Segment> lines;
  lines.reserve(nfaces);
  
  std::vector<vec3d> vertices(nverts);
  for (int i=0; i<nverts; ++i) {
    in >> vertices[i].x >> vertices[i].y >> vertices[i].z;
  }
  
  for (int i=0; i<nfaces; ++i) {
    int sz, a, b;
    Segment s;
    in >> sz >> a >> b;
    s.a = vertices.at(a);
    s.b = vertices.at(b);
    lines.push_back(s);
  }
  
  std::clog << "Loaded " << lines.size() << " lines" << std::endl;
  
  return lines;
}

void writeOFFModel(const TriMesh& model, std::ostream& out){
  out << "OFF" << std::endl;
  int m_size= model.faces.size();
  
  out << m_size*3 << " " << m_size << " " << m_size*3 << std::endl;
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  for(;ite != end; ++ite){
    out << ite->a.x << " " << ite->a.y << " " << ite->a.z << std::endl;
    out << ite->b.x << " " << ite->b.y << " " << ite->b.z << std::endl;
    out << ite->c.x << " " << ite->c.y << " " << ite->c.z << std::endl;
  }
  
  for(int i= 0; i < m_size; i++){
    out << "3 " << 3*i << " " << 3*i+1 << " " << 3*i+2 << std::endl;
  }
}

#else
bool input_model = true; // se um modelo foi fornecido na chamada do programa
bool normal_dc3d = false; // depth complexity normal ou random
TriMesh originalMesh; // modelo fornecido para ser particionado

DepthComplexity3D *dc3d = NULL;
RDepthComplexity3D *dc3dr = NULL;
//________________________________________________ CAMERA
Camera camera;
//______________ MOUSE
int mDx = 0;
int mDy = 0;
bool mclicked;
int mbutton;
int mwhell;
//______________ WINDOW
static int winWidth, winHeight;

//subroutines
int doInteractive();
void draw();
void GLFWCALL mouse_motion(int x, int y);
void GLFWCALL mouse_click(int button, int action);
void GLFWCALL mouse_whell(int pos);
void GLFWCALL WindowSizeCB(int width, int height);

int main(int argc, char** argv) {
  if (argc == 1) {
        std::cerr << "[ERROR] Missing Input File!" << std::endl;
        return 1;
  }
 
  glutInit(&argc,argv);
    
  try {
    std::ifstream file(argv[1]);
    std::string ext = getExtension(argv[1]);

    TriMesh mesh;

      if (ext == "off" || ext == "OFF")
          mesh = loadOFFMesh(file);
      else if (ext == "obj" || ext == "OBJ")
          mesh = loadOBJMesh(file);
      else
          throw "Unknown file type!";

      if (doInteractive(mesh))
          return 1;

  }
  catch (const char* msg)  {
      std::cerr << "Failed: " << msg << std::endl;
      return 1;
  }
  catch (std::string msg) {
      std::cerr << "Failed: " << msg << std::endl;
  }    
}

//_______________________________________________________________ Called when a mouse button is pressed or released
void GLFWCALL mouse_click(int button, int action){
	if(TwEventMouseButtonGLFW(button,action))
		return;
	glfwGetMousePos(&mDx,&mDy);
	mclicked=action==GLFW_PRESS;
	mbutton=button;
}

//_______________________________________________________________ Called when the mouse whell move
void GLFWCALL mouse_whell(int pos){
  if(TwEventMouseWheelGLFW(pos)){
    mwhell = pos;
    return;
  }
  float Dw = pos - mwhell;
  float delta = 0.1;
  
  camera.MoveFrente(Dw * delta);
  
  mwhell = pos;
}
//_______________________________________________________________ Called when a mouse move and a button is pressed
void GLFWCALL mouse_motion(int x, int y){
	if(TwEventMousePosGLFW(x,y))
		return;
	if( mclicked ){
		float dx = mDx - x;
		float dy = mDy - y;
		float d = sqrt(dx*dx + dy*dy);
		float delta = 0.001;

		switch(mbutton){
			case GLFW_MOUSE_BUTTON_LEFT : //look
				//if( glutGetModifiers() == GLUT_ACTIVE_SHIFT){
					camera.lookLefRigObj(dx * delta );
					camera.lookUpDownObj(dy * delta);
				//} else { 
					camera.lookLefRig(dx * delta);
					camera.lookUpDown(dy * delta);
				}//
			break;
			case GLFW_MOUSE_BUTTON_RIGHT:			
				//if( glutGetModifiers() != GLUT_ACTIVE_SHIFT){
					camera.MoveLado(dx*delta);
					camera.MoveCimaBaixo(-dy*delta);
				//}else{
					camera.MoveLadoObj(dx*delta);
					camera.MoveCimaBaixoObj(-dy*delta);				
				//}//
			break;
			case GLFW_MOUSE_BUTTON_MIDDLE: 
				if( dy>0) d = -d;
				//if( glutGetModifiers() != GLUT_ACTIVE_SHIFT)
					camera.MoveFrente(d*delta);
				//else
					camera.MoveFrenteObj(d*delta);//
			break;
		}//end switch
		mDx = x;	mDy = y;
	}//end if
}

// Callback function called by GLFW when window size changes
void GLFWCALL WindowSizeCB(int width, int height)
{
    winWidth = width;
    winHeight = height;
    // Send the new window size to AntTweakBar
    TwWindowSize(width, height);
}

int doInteractive(TriMesh& mesh)
{
   
    glfwInit();
    std::atexit(glfwTerminate);
    
    GLFWvidmode mode;
    
    glfwGetDesktopMode(&mode);
    if( !glfwOpenWindow(1024, 768, mode.RedBits, mode.GreenBits, mode.BlueBits, 
                        0, 16, 0, GLFW_WINDOW) )
    {
        std::cerr << "failed to open window!" << std::endl;
        return -1;
    }
    
    // initialize GLEW
    GLenum glewStatus = glewInit();
    if (glewStatus != GLEW_OK){
      std::cerr << "[ERROR] "<< glewGetErrorString(glewStatus)<<std::endl;
    }
    
    // Print OPENGL, SHADER and GLEW versions
    std::clog << "----- << VERSION >>\n";
    std::clog << "OPENGL VERSION: " << glGetString(GL_VERSION) << std::endl;
    std::clog << "SHADER VERSION: " << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
    std::cerr << "GLEW VERSION: "<<glewGetString(GLEW_VERSION)<<std::endl;
    std::clog << "---------------- \n";
 

    glfwEnable(GLFW_MOUSE_CURSOR);
    glfwEnable(GLFW_KEY_REPEAT);
    glfwSetWindowTitle("Plane-Triangle intersection test");

	
    // Initialize AntTweakBar
    if( !TwInit(TW_OPENGL, NULL) )
    {
        std::cerr << "AntTweakBar initialization failed: " << TwGetLastError() << std::endl;
        return 1;
    }
    // Set GLFW event callbacks
    glfwSetWindowSizeCallback(WindowSizeCB);

    glfwSetMouseButtonCallback(mouse_click);
    glfwSetMousePosCallback(mouse_motion);
    glfwSetMouseWheelCallback(mouse_whell);
    glfwSetKeyCallback((GLFWkeyfun)TwEventKeyGLFW);
    glfwSetCharCallback((GLFWcharfun)TwEventCharGLFW);

    mwhell = glfwGetMouseWheel();
    
    TwBar *bar = TwNewBar("Controls");
    TwDefine(" GLOBAL ");
	
    vec3f top(0.25, 0.25, .5), mid(0.75, 0.75, .85), bot(1, 1, 1);

    vec4f objdiff(0.55, 0.5, 0, 0.5), objspec(.75, .75, .75, .2);
    GLfloat shine = 50;
    bool showObj = true;
    
    #ifdef USE_RANDOM_DC3D
		if (strcmp(filenameRays, "")!=0)
			dc3d = new RDepthComplexity3D(512, 512, 2, filenameRays);
		else
			dc3d = new RDepthComplexity3D(512, 512, 2);
    #else
    dc3d = new DepthComplexity3D(512, 512, 2);
    cout << "dc3d loaded" << endl;
    #endif
    dc3d->setComputeMaximumRays(true);
    dc3d->setComputeHistogram(true);
    dc3d->setThreshold(10);
    
    TwAddVarRW(bar, "showPlanes", TW_TYPE_BOOLCPP, &showPlanes, " label='show discret. planes' ");

    TwAddVarRW(bar, "goodRays", TW_TYPE_BOOLCPP, &doGoodRays, " label='show more rays' ");

    TwAddVarRW(bar, "goodThreshold", TW_TYPE_UINT32, &dc3d->_threshold, " label='intersection threshold' min=0 ");

    TwAddVarRW(bar, "discretSteps", TW_TYPE_UINT32, &dc3d->_discretSteps, " label='discret. steps' min=2 ");

    TwAddButton(bar, "recompute", recompute, (void*)&mesh, " label='Recompute' ");

    TwAddVarRO(bar, "maxDepth", TW_TYPE_UINT32, &dc3d->_maximum, " label='Max. depth' ");

    TwAddVarRW(bar, "top", TW_TYPE_COLOR3F, &top.x, " group='background' ");
    TwAddVarRW(bar, "mid", TW_TYPE_COLOR3F, &mid.x, " group='background' ");
    TwAddVarRW(bar, "bot", TW_TYPE_COLOR3F, &bot.x, " group='background' ");

    TwAddVarRW(bar, "Diff", TW_TYPE_COLOR4F, &objdiff.x, " group='Object' ");
    TwAddVarRW(bar, "Spec", TW_TYPE_COLOR4F, &objspec.x, " group='Object' ");
    TwAddVarRW(bar, "Shin", TW_TYPE_FLOAT, &shine, " group='Object' min='1' max='128' ");
    TwAddVarRW(bar, "Show", TW_TYPE_BOOLCPP, &showObj, " group='Object' ");
		
    TwAddVarRW(bar, "radius", TW_TYPE_FLOAT, &radius, "  group='Sphere' label='radius' min=0.0 step=0.001 max=2.0");
    TwAddVarRW(bar, "Color", TW_TYPE_COLOR4F, &sphereColor.x, " group='Sphere' ");
    //TwAddVarRW(bar, "Show Ray", TW_TYPE_UINT32, &showRayIndex, " group='rays' min=0");

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);

    //Camera cam;
    BoundingBox aabb = mesh.aabb;
    
    camera.bbox(float3(aabb.min.x,aabb.min.y,aabb.min.z), float3(aabb.max.x,aabb.max.y,aabb.max.z), true );
		camera.front();
    
    //cam.target = aabb.center();
    //cam.up = vec3f(0, 1, 0);
    //cam.pos = cam.target + vec3f(0, 0, 2*aabb.extents().z);

    while( glfwGetWindowParam(GLFW_OPENED) && !glfwGetKey(GLFW_KEY_ESC) ) {
        glClear( GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT );

        drawBackground(top, mid, bot);

        setupCamera(camera);
        
        //camera.update();	
	    camera.lookAt();//

        //GLfloat lpos[4] = { camera.GetEye().x, camera.GetEye().y, camera.GetEye().z, 1 };
        glLightfv(GL_LIGHT0, GL_POSITION, lpos);//
       

        //drawPlaneIntersection(intersectionVectors);
        drawRays();


				
        //glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, &objdiff.x);
        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, &objspec.x);
        glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, shine);
        if (showObj) drawMesh(mesh, vec3f(camera.GetDir().x,camera.GetDir().y,camera.GetDir().z));

        Triangle *t = &mesh.faces[550];
        t->ca = vec4d(1.0f, 0.0f, 0.0f, 0.7f);
        t->cb = vec4d(1.0f, 0.0f, 0.0f, 0.7f);
        t->cc = vec4d(1.0f, 0.0f, 0.0f, 0.7f);

        t = &mesh.faces[608];
        t->ca = vec4d(1.0f, 0.0f, 0.0f, 0.7f);
        t->cb = vec4d(1.0f, 0.0f, 0.0f, 0.7f);
        t->cc = vec4d(1.0f, 0.0f, 0.0f, 0.7f);

        // Draw tweak bars
        TwDraw();

        // Present frame buffer
        glfwSwapBuffers();
    }

    return 0;
}
#endif
*/
void mergeTriangleBB ( BoundingBox& aabb, const Triangle t){
  aabb.merge(t.a);
  aabb.merge(t.b);
  aabb.merge(t.c);
}

void  subDivideModel(const vec4d plane, const TriMesh& model, TriMesh& partA,
        TriMesh& partB){
  //vec3d model_center = ((model.aabb.max + model.aabb.min)/2.0);
  /*
  cout << plane << std::endl << plane.xyz()*(-plane.w) << std::endl;
  cout << dot(plane, vec4d(plane.xyz()*plane.w,1))<<endl;
  */
  std::size_t numModelTrian = model.faces.size();
  
  partA.faces.reserve(numModelTrian/2);
  partB.faces.reserve(numModelTrian/2);
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  
  for(;ite != end; ite++){

    bool divideTriangle;
    TriMesh *partOne,
            *partTwo;
    Triangle t;
    
    switch(getPlaneTriangleIntersection(plane, *ite)){
      case ALL_ABOVE_PLANE:
        divideTriangle = false;
        partOne = &partA;
        t = *ite;
        break;
      case ALL_BELLOW_PLANE:
        divideTriangle = false;
        partOne = &partB;
        t = *ite;
        break;
      case ONLY_A_ABOVE_PLANE:
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_A_BELLOW_PLANE:
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_B_ABOVE_PLANE:
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_B_BELLOW_PLANE:
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_C_ABOVE_PLANE:
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      case ONLY_C_BELLOW_PLANE:
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      default:
        cout << "ERROR: Não foi possivel determinar a possição do triangulo em relação ao plano" << std::endl;
        exit(-1);
    }
    
    if(!divideTriangle){
      partOne->faces.push_back(t);
      mergeTriangleBB(partOne->aabb, t);
    }else{
      Triangle halfT, tb, tc;
      
      halfT = cutTriangle(plane, t);
      
      partOne->faces.push_back(halfT);
      mergeTriangleBB(partOne->aabb, halfT);
      
      tb = Triangle();
      tb.a = halfT.b;
      tb.b = t.b;
      tb.c = t.c;
      tb.na = t.nb =
      t.nc = halfT.nb;
      partTwo->faces.push_back(tb);
      mergeTriangleBB(partTwo->aabb, tb);
      
      tc = Triangle();
      tc.a = halfT.b;
      tc.b = t.c;
      tc.c = halfT.c;
      tc.na = tc.nb =
      tc.nc = halfT.nb;
      partTwo->faces.push_back(tc);
      mergeTriangleBB(partTwo->aabb, tc);
    }
  }
}

vec4d makePlane(const vec3d& normal, const vec3d& point){
  
  double d = dot(normal, point);
  return vec4d(normal, d);
  
}

int getPlaneTriangleIntersection(const vec4d& plane, const Triangle& triangle){
  bool AAbove,
       BAbove,
       CAbove;
  
  if(dot(plane, vec4d(triangle.a, -1)) >= 0){
    AAbove = true;
  }else{
    AAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.b, -1)) >= 0){
    BAbove = true;
  }else{
    BAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.c, -1)) >= 0){
    CAbove = true;
  }else{
    CAbove = false;
  }
  
  if(AAbove && BAbove && CAbove){ // todos acima?
    return ALL_ABOVE_PLANE;
  }else if(!AAbove && !BAbove && !CAbove){ // todos abaixo?
    return ALL_BELLOW_PLANE;
  }else if(AAbove){ //no inicio desta linha se tem certeza que a b c não estão no mesmo lado do plano
    if(BAbove){ 
      return ONLY_C_BELLOW_PLANE;
    }else{
      if(CAbove){
        return ONLY_B_BELLOW_PLANE;
      }else{
        return ONLY_A_ABOVE_PLANE;
      }
    }
  }else if(BAbove){ //AAbove = false
    if(CAbove){
      return ONLY_A_BELLOW_PLANE;
    }else{// AAbove = CAbove = false
      return ONLY_B_ABOVE_PLANE;
    }
  }else{ //AAbove = BAbove = false, como os tres não são iguais CAbove = true
    return ONLY_C_ABOVE_PLANE;
  }
}

vec3d linePlaneIntersection(const Segment& line, const vec4d& plane){
  // intersecção de uma reta e um planos com equaçoes parametricas
  // formula vista em paulbourke.net/geometry/planeline
  vec3d dir = line.a - line.b; dir.normalize();
	vec3d p0 = plane.xyz() * plane.w; //a point over the plane
	double d = dot(plane.xyz(),(p0-line.a)) / dot(plane.xyz(),dir);
	vec3d intercept = line.a + dir*d;
  
	return intercept;
  
}

/*
 * Recebe um plano e um triangulo, onde o ponto a do triangulo esta do outro lado
 * do plano em comparação com os ponto b e c. Esta rotação dos pontos do triangulo deve
 * ser feita antes da chamada da função
 */
Triangle cutTriangle(const vec4d& plane, const Triangle& triangle){
  
  vec3d new_b, new_c;
  
  new_b = linePlaneIntersection( Segment(triangle.a, triangle.b), plane);
  new_c = linePlaneIntersection( Segment(triangle.a, triangle.c), plane);
  
  Triangle triangleHalf;
  
  triangleHalf.a = triangle.a;
  triangleHalf.b = new_b;
  triangleHalf.c = new_c;
  
  triangleHalf.na = triangleHalf.nb 
          = triangleHalf.nc = triangle.na;
  return triangleHalf;
}

/*
 * Função que ira definir o plano divisor do modelo a partir das linha que atravesam
 * o modelo um numero maximo de vezes, a heuristica usada tenta diminuir ao maximo o
 * número de intersecções nos submodelos.
 */
vec4d defineCuttingPlane(const vector<Segment> lines, const BoundingBox aabb){
  
  //cout << "max:" << aabb.max << ";min:" << aabb.min << endl;
  vector<W_Plane> cutting_planes; //planes found that will be interpolated in the end 

  vector<int> retest_seg;// positions of elements with needs to be retested
  vector<int> idx_segs;// positions of elements to be tested
  idx_segs.reserve(lines.size());//in the fist pass all elements will be tested
  
  for (uint i = 0; i < lines.size(); i++){
    idx_segs.push_back(i);
  }
  
  //init test
  while(idx_segs.size() > 1){//in case there is only one line to be tested another heuristic must be used
    
    //find a inital plane to be compared with the rest of lines
    int first_idx = 1;
    bool plane_found = false;
    W_Plane cut_plane;
    
    //compare two lines to find a plane inside the aabb
    while(not plane_found){
      Segment seg_btw;
              
      try{
        seg_btw = 
              findSegmentBetweenLines(lines.at(idx_segs.at(0)), 
                                      lines.at(idx_segs.at(first_idx)));
      }catch(std::out_of_range){
        std::cout << first_idx << ":" << plane_found << endl;
        
        break;
      }
      if(seg_btw.active){
        
        if(insideAABB(seg_btw.a, aabb) && insideAABB(seg_btw.b, aabb)){

          plane_found = true;
          cut_plane.p0 = (seg_btw.a + seg_btw.b)/2.0;
          
          vec3d normA, normB;
          
          try{
            normA = lines.at(idx_segs.at(0)).b - lines.at(idx_segs.at(0)).a;
            normB = lines.at(idx_segs.at(first_idx)).b - lines.at(idx_segs.at(first_idx)).a;
          }catch(std::out_of_range){
            cout << first_idx << ";" << plane_found << endl;
            
            break;
          }

          normA = normA/normA.length();
          normB = normB/normB.length();

          // for the angle betwen the lines a verifications is
          // needed so the smaller angle betwen then is used
          if (dot(normA, normB) >= 0){
            cut_plane.vet_dir = normA + normB;
          }else{
            cut_plane.vet_dir = normA - normB;
          }

        }else{
          retest_seg.push_back(idx_segs.at(first_idx));
        }
      }
      first_idx++;
      
    }
    
    //cout << "pass" <<endl;
    double lines_used = 2;// 
    //start comparing plane with lines to insterpolate a new plane
    for(uint i = first_idx; i < idx_segs.size(); i++){
      Segment line_plane = Segment(cut_plane.p0, cut_plane.vet_dir+cut_plane.p0);
      Segment seg_btw = 
              findSegmentBetweenLines(line_plane, 
                                      lines.at(idx_segs.at(first_idx)));
      if(seg_btw.active){
           
        if(insideAABB(seg_btw.a, aabb) && insideAABB(seg_btw.b, aabb)){
          
          //weighted mean for the interpolations with the plan and the line
          cut_plane.p0 = (lines_used*cut_plane.p0 + seg_btw.b)/(++lines_used);

          vec3d norm = lines.at(idx_segs.at(first_idx)).b - lines.at(idx_segs.at(first_idx)).a;

          norm = norm/norm.length();

          // for the angle betwen the lines a verifications is
          // needed so the smaller angle betwen then is used
          if (dot(cut_plane.vet_dir, norm) >= 0){
            cut_plane.vet_dir += norm;
          }else{
            cut_plane.vet_dir -= norm;
          }

        }else{
          retest_seg.push_back(idx_segs.at(first_idx));
          first_idx++;
        }
      }else{//parallel lines are disconsidered
        first_idx++;
      }
    }
    
    cut_plane.weight = lines_used;
    cutting_planes.push_back(cut_plane);
    
    //cout << lines_used<< ":" << retest_seg.size()  << endl;
    //setup the lined who need to be retested
    idx_segs.swap(retest_seg);
    retest_seg.clear();
  }
  
  //use another heuristic to find the cutting plane using one line
  if(not idx_segs.empty()){
    vector<int>::const_iterator ite = idx_segs.begin();
    vector<int>::const_iterator end = idx_segs.end();
    
    for(; ite != end; ite++){
      W_Plane S_lineP;
      
      S_lineP.p0 = (lines.at(*ite).a + lines.at(*ite).b)/2.0;
      
      S_lineP.vet_dir = lines.at(*ite).b - lines.at(*ite).a;
      S_lineP.vet_dir.normalize();
      
      S_lineP.weight = 1;
      
      cutting_planes.push_back(S_lineP);
    }
  }
  //interpolate all the planes found
  vec3d ret_p0;
  vec3d ret_normal;
  double weights = 0;
  
  vector<W_Plane>::const_iterator ite = cutting_planes.begin();
  vector<W_Plane>::const_iterator end = cutting_planes.end();
  
  ret_p0 = ite->p0 * ite->weight;
  weights = ite->weight;
  ret_normal = ite->vet_dir;
  
  for(;ite != end; ++ite){
    ret_p0 += ite->p0*ite->weight;
    weights += ite->weight;
    
    if(dot(ret_normal, ite->vet_dir) >= 0){
      ret_normal += ite->vet_dir;
    }else{
      ret_normal -= ite->vet_dir;
    }
  }
  
  ret_p0 = ret_p0/weights;
  ret_normal.normalize();
  
  if(insideAABB(ret_p0, aabb)){
      std::cout << ret_p0<<endl;
     return makePlane(ret_normal, ret_p0); 
  }else{
      std::cout << "out" << std::endl;
      return makePlane(ret_normal, (aabb.max+aabb.min)/2.0);
  }
}

/*
 * Função que acha o menor segmento de reta entre duas linhas não paralelas
 * a reta será perpendicular as duas linhas passadas,
 * caso as linhas sejam paralelas o campo active do segmento retorna do será falso.
 * O ponto inicial do segmento fara parte da primeira linha passada.
 * 
 */
Segment findSegmentBetweenLines(Segment lineA, Segment lineB){
  vec3d u = lineA.b - lineA.a,
        v = lineB.b - lineB.a,
        w0= lineA.a - lineB.a;
  
  double a = dot(u,u),
         b = dot(v,v),
         c = dot(u,v);
  
  double denominator = a*b - c*c;
  
  if (denominator == 0){ // the 2 lines are paralels
    Segment paralel = Segment();
    paralel.active = false;            
    
    return paralel;
  }
  
  double d = dot(u,w0),
         e = dot(v,w0);
  
  double Ap = (c*e-d*b)/denominator,
         Bp = (a*e-d*c)/denominator;
  
  vec3d pnt0 = lineA.a + u*Ap,
        pnt1 = lineB.a + v*Bp;
  Segment ret(pnt0, pnt1);
  ret.active = true;
  return ret;
  
}

/*
 * Test if point is inside the bounding box aabb 
 * 
 */ 
bool insideAABB(const vec3d point, const BoundingBox aabb){
  if(point.x > aabb.max.x) return false;  
  if(point.x < aabb.min.x) return false;
  if(point.y > aabb.max.y) return false;
  if(point.y < aabb.min.y) return false;
  if(point.z > aabb.max.z) return false;
  if(point.z < aabb.min.z) return false;
  return true;
}