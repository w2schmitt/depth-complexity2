/* 
 * File:   bps_model.cpp
 * Author: Affonso
 *
 * Created on 16 de Maio de 2012, 14:39
 */

#include "flags.h"
#include "util.h"
#ifdef USE_RANDOM_DC3D
#include "dc_3d_random.h"
#else
#include "dc_3d.h"
#endif
#include "timer.h"
#include "camera/float3.h"
#include "camera/Camera.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
/*#include <GL/glew.h>
#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif*/
void  subDivideModel(const vec4d plane, const TriMesh& model, TriMesh& partA,
        TriMesh& partB);
vec4d makePlane(const vec3d& normal, const vec3d& point);
std::string getExtension(const std::string& filename);
void writeOFFModel(const TriMesh& model, std::ostream& out);
std::vector<Segment> loadOFFLines(std::istream& in);

/*
 * 
 */
int main(int argc, char** argv) {
  cmd_usage("Program to divide a model based in the lines generated by depthcomplexity3d_offline");
  
  const char *filename = cmd_option("-f", "", "Model in the OBJ or OFF format");
  const char *modelRays = cmd_option("-r", "", "OFF File with maximum intersections lines");
  
  const char *modelA = cmd_option("-fa", "", "OFF file with the first part of the model");
  const char *modelB = cmd_option("-fb", "", "OFF file with the other part of the model");
  
  try{
    if(strcmp(filename, "")==0)
      throw "No model file specified";
    
    //carrega modelo a ser dividido
    tic();
    std::ifstream file(filename);
    std::string ext = getExtension(filename);
    TriMesh mesh;
    if (ext == "off" || ext == "OFF")
      mesh = loadOFFMesh(file);
    else if (ext == "obj" || ext == "OBJ")
      mesh = loadOBJMesh(file);
    else
      throw "Unknown file type for model!";
    file.close();
    toc("Loading Mesh");
    
    //Carrega linhas com o maximo de interseções
    tic();
    std::ifstream line_file(modelRays);
    std::string ext_line = getExtension(modelRays);
    std::vector<Segment> lines;
    if (ext_line == "off" || ext_line == "OFF")
      lines = loadOFFLines(line_file);
    else
      throw "Unknown file type for lines!";
    file.close();
    toc("Loading Lines");
    
    TriMesh part_a, part_b;
    
    vec3d planeNormal = lines.at(0).a - lines.at(0).b,
          model_center = ((mesh.aabb.max + mesh.aabb.min)/2.0);
    planeNormal.normalize();
    cout << model_center << std::endl;
    vec4d plane = makePlane(planeNormal, model_center);
    subDivideModel(plane, mesh, part_a, part_b);
    
    //write part_a of the model
    if (strcmp(modelA, "")!=0) {
      std::string extOff = getExtension(modelA);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelA);
        writeOFFModel(part_a,fileRays);
        fileRays.close();
      } else throw "Model A file should be *.off!";
    }
    
    //write part_a of the model
    if (strcmp(modelB, "")!=0) {
      std::string extOff = getExtension(modelB);
      if (extOff == "off" || extOff == "OFF") {
        std::ofstream fileRays(modelB);
        writeOFFModel(part_b,fileRays);
        fileRays.close();
      } else throw "Model B file should be *.off!";
    }
    
  } catch (const char* msg)  {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  } catch (std::string msg) {
    std::cerr << "Failed: " << msg << std::endl;
    return 1;
  }
  
  return 0;
}

std::vector<Segment> loadOFFLines(std::istream& in){
  
  std::clog << "Loading OFF file" << std::endl;

  std::string head;
  in >> head;
  if (head != "OFF")
    throw "Does not start with OFF!";

  int nverts, nfaces, nedges;
  
  if (!(in >> nverts >> nfaces >> nedges))
    throw "Could not read number of vertices, faces, edges";

  std::vector<Segment> lines;
  lines.reserve(nfaces);
  
  std::vector<vec3d> vertices(nverts);
  for (int i=0; i<nverts; ++i) {
    in >> vertices[i].x >> vertices[i].y >> vertices[i].z;
  }
  
  for (int i=0; i<nfaces; ++i) {
    int sz, a, b;
    Segment s;
    in >> sz >> a >> b;
    s.a = vertices.at(a);
    s.b = vertices.at(b);
    lines.push_back(s);
  }
  
  std::clog << "Loaded " << lines.size() << " lines" << std::endl;
  
  return lines;
}

std::string getExtension(const std::string& filename) {
  std::string::size_type dotpos = filename.rfind(".");
  if (dotpos != std::string::npos)
    return filename.substr(dotpos+1);
  return "";
}


void writeOFFModel(const TriMesh& model, std::ostream& out){
  out << "OFF" << std::endl;
  int m_size= model.faces.size();
  
  out << m_size*3 << " " << m_size << " " << m_size*3 << std::endl;
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  for(;ite != end; ++ite){
    out << ite->a.x << " " << ite->a.y << " " << ite->a.z << std::endl;
    out << ite->b.x << " " << ite->b.y << " " << ite->b.z << std::endl;
    out << ite->c.x << " " << ite->c.y << " " << ite->c.z << std::endl;
  }
  
  for(int i= 0; i < m_size; i++){
    out << "3 " << 3*i << " " << 3*i+1 << " " << 3*i+2 << std::endl;
  }
}


//defines usados por getPlaneTriangleIntersection para comunicar quais pontos do
//triangulo estão abaixo ou acima do plano
#define ALL_BELLOW_PLANE      -4
#define ONLY_C_ABOVE_PLANE    -3
#define ONLY_B_ABOVE_PLANE    -2
#define ONLY_A_ABOVE_PLANE    -1
#define ONLY_A_BELLOW_PLANE   1
#define ONLY_B_BELLOW_PLANE   2
#define ONLY_C_BELLOW_PLANE   3
#define ALL_ABOVE_PLANE       4  

int getPlaneTriangleIntersection(const vec4d& plane, const Triangle& triangle);
Triangle cutTriangle(const vec4d& plane, const Triangle& triangle);

void mergeTriangleBB ( BoundingBox& aabb, const Triangle t){
  aabb.merge(t.a);
  aabb.merge(t.b);
  aabb.merge(t.c);
}

void  subDivideModel(const vec4d plane, const TriMesh& model, TriMesh& partA,
        TriMesh& partB){
  vec3d model_center = ((model.aabb.max + model.aabb.min)/2.0);
  
  cout << plane << std::endl << model_center << std::endl;
  cout << dot(plane, vec4d(model_center,1))<<endl;
  
  std::size_t numModelTrian = model.faces.size();
  
  partA.faces.reserve(numModelTrian/2);
  partB.faces.reserve(numModelTrian/2);
  
  std::vector<Triangle>::const_iterator ite = model.faces.begin();
  std::vector<Triangle>::const_iterator end = model.faces.end();
  
  for(;ite != end; ++ite){

    bool divideTriangle;
    TriMesh *partOne,
            *partTwo;
    Triangle t;
    
    switch(getPlaneTriangleIntersection(plane, *ite)){
      case ALL_ABOVE_PLANE:
        //cout << "ALL_ABOVE_PLANE" << std::endl;
        divideTriangle = false;
        partOne = &partA;
        t = *ite;
        break;
      case ALL_BELLOW_PLANE:
        //cout << "ALL_BELLOW_PLANE" << std::endl;
        divideTriangle = false;
        partOne = &partB;
        t = *ite;
        break;
      case ONLY_A_ABOVE_PLANE:
        //cout << "ONLY_A_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_A_BELLOW_PLANE:
        //cout << "ONLY_A_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->a;
        t.b = ite->b;
        t.c = ite->c;
        t.na = t.nb =
        t.nc = ite->nc;
        break;
      case ONLY_B_ABOVE_PLANE:
        //cout << "ONLY_B_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_B_BELLOW_PLANE:
        //cout << "ONLY_B_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->b;
        t.b = ite->c;
        t.c = ite->a;
        t.na = t.nb =
        t.nc = ite->na;
        break;
      case ONLY_C_ABOVE_PLANE:
        //cout << "ONLY_C_ABOVE_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partA;
        partTwo = &partB;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      case ONLY_C_BELLOW_PLANE:
        //cout << "ONLY_C_BELLOW_PLANE" << std::endl;
        divideTriangle = true;
        partOne = &partB;
        partTwo = &partA;
        t.a = ite->c;
        t.b = ite->a;
        t.c = ite->b;
        t.na = t.nb =
        t.nc = ite->nb;
        break;
      default:
        cout << "ERROR: Não foi possivel determinar a possição do triangulo em relação ao plano" << std::endl;
        exit(-1);
    }
    
    //divideTriangle = false;
    
    if(!divideTriangle){
      partOne->faces.push_back(t);
      mergeTriangleBB(partOne->aabb, t);
    }else{
      Triangle halfT, tb, tc;
      
      halfT = cutTriangle(plane, t);
      
      partOne->faces.push_back(halfT);
      mergeTriangleBB(partOne->aabb, halfT);
      
      tb = Triangle();
      tb.a = halfT.b;
      tb.b = t.b;
      tb.c = t.c;
      tb.na = t.nb =
      t.nc = halfT.nb;
      partTwo->faces.push_back(tb);
      mergeTriangleBB(partTwo->aabb, tb);
      
      tc = Triangle();
      tc.a = halfT.b;
      tc.b = t.c;
      tc.c = halfT.c;
      tc.na = tc.nb =
      tc.nc = halfT.nb;
      partTwo->faces.push_back(tc);
      mergeTriangleBB(partTwo->aabb, tc);
    }
  }
}

vec4d makePlane(const vec3d& normal, const vec3d& point){
  
  double d = dot(normal, point);
  return vec4d(normal, -d);
  
}

int getPlaneTriangleIntersection(const vec4d& plane, const Triangle& triangle){
  bool AAbove,
       BAbove,
       CAbove;
  
  if(dot(plane, vec4d(triangle.a, -1)) >= 0){
    AAbove = true;
  }else{
    AAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.b, -1)) >= 0){
    BAbove = true;
  }else{
    BAbove = false;
  }
  
  if(dot(plane, vec4d(triangle.c, -1)) >= 0){
    CAbove = true;
  }else{
    CAbove = false;
  }
  
  if(AAbove && BAbove && CAbove){ // todos acima?
    return ALL_ABOVE_PLANE;
  }else if(!AAbove && !BAbove && !CAbove){ // todos abaixo?
    return ALL_BELLOW_PLANE;
  }else if(AAbove){ //no inicio desta linha se tem certeza que a b c não estão no mesmo lado do plano
    if(BAbove){ 
      return ONLY_C_BELLOW_PLANE;
    }else{
      if(CAbove){
        return ONLY_B_BELLOW_PLANE;
      }else{
        return ONLY_A_ABOVE_PLANE;
      }
    }
  }else if(BAbove){ //AAbove = false
    if(CAbove){
      return ONLY_A_BELLOW_PLANE;
    }else{// AAbove = CAbove = false
      return ONLY_B_ABOVE_PLANE;
    }
  }else{ //AAbove = BAbove = false, como os tres não são iguais CAbove = true
    return ONLY_C_ABOVE_PLANE;
  }
}

vec3d linePlaneIntersection(const Segment& line, const vec4d& plane){
  // intersecção de uma reta e um planos com equaçoes parametricas
  // formula achada em paulbourke.net/geometry/planeline
  /*
  double divisor, dividend;
  
  dividend = dot(plane, vec4d(line.a,1));
  
  divisor = dot(plane, vec4d(line.a-line.b,0));
  
  
  if(divisor == 0){
    printf("ERROR: o triangulo não é cortado pelo plano divisor\n");
    exit(-1);
  }
  
  if(dividend == 0){
    printf("ERROR - dividend = 0");
  }
  
  double u = dividend/divisor;
  
  vec3d pnt_intersect;
  
  pnt_intersect = line.a + u*(line.b - line.a);
//  
//  cout << "[" << plane.x << ',' << plane.y << ',' << plane.z << ',' << plane.w << ']' 
//          << pnt_intersect << line.a << line.b << std::endl;
  
  return pnt_intersect;
  */
  vec3d dir = line.a - line.b; dir.normalize();
	vec3d p0 = plane.xyz() * plane.w; //a point over the plane
	double d = dot(plane.xyz(),(p0-line.a)) / dot(plane.xyz(),dir);
	vec3d intercept = line.a + dir*d;
  
	return intercept;
  
}

// recebe um plano e um triangulo, onde o ponto a do triangulo esta do outro lado
// do plano em comparação com os ponto b e c.
Triangle cutTriangle(const vec4d& plane, const Triangle& triangle){
  
  vec3d new_b, new_c;
  
  new_b = linePlaneIntersection( Segment(triangle.a, triangle.b), plane);
  new_c = linePlaneIntersection( Segment(triangle.a, triangle.c), plane);
  
  Triangle triangleHalf;
  
  triangleHalf.a = triangle.a;
  triangleHalf.b = new_b;
  triangleHalf.c = new_c;
  
  triangleHalf.na = triangleHalf.nb 
          = triangleHalf.nc = triangle.na;
  //cout << "A:"<< triangle.a << "B:"<< triangle.b << "C:"<< triangle.c << " Half: "
  //     << "A:"<< triangleHalf.a << "B:"<< triangleHalf.b << "C:"<< triangleHalf.c << std::endl;
  return triangleHalf;
}